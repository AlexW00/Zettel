//
//  Note.swift
//  Zettel
//
//  Created for Zettel project
//

import Foundation

/// Errors related to note operations
enum NoteError: LocalizedError {
    case corruptedFile
    case fileSystemError(String)
    case encodingError

    var errorDescription: String? {
        switch self {
        case .corruptedFile:
            return "The note file is corrupted and cannot be read."
        case .fileSystemError(let message):
            return "File system error: \(message)"
        case .encodingError:
            return "Unable to encode or decode the note content."
        }
    }
}

/// Wrapper class for cached tag data to work with NSCache
class CachedTags {
    let hash: Int
    let tags: Set<String>

    init(hash: Int, tags: Set<String>) {
        self.hash = hash
        self.tags = tags
    }
}

/// Thread-safe cache manager for tag extraction to avoid repeated regex operations
class TagCacheManager {
    static let shared = TagCacheManager()

    private let cache = NSCache<NSString, CachedTags>()
    private let cacheQueue = DispatchQueue(label: "com.Zettel.tagcache", attributes: .concurrent)

    private init() {
        cache.countLimit = CacheConstants.tagCacheLimit // Limit number of cached items
        cache.totalCostLimit = CacheConstants.tagCacheSizeLimit // 10MB limit
    }
    
    func getExtractedTags(for note: Note) -> Set<String> {
        let noteId = NSString(string: note.id)
        let contentHash = (note.title + note.content).hashValue

        // Check cache first (concurrent read)
        return cacheQueue.sync {
            if let cached = cache.object(forKey: noteId), cached.hash == contentHash {
                return cached.tags
            }

            // Extract tags and cache the result (barrier write)
            let tags = TagParser.extractTags(from: note)
            let cachedTags = CachedTags(hash: contentHash, tags: tags)
            
            cacheQueue.async(flags: .barrier) {
                self.cache.setObject(cachedTags, forKey: noteId)
            }

            return tags
        }
    }

    func invalidateCache(for noteId: String) {
        cacheQueue.async(flags: .barrier) {
            self.cache.removeObject(forKey: NSString(string: noteId))
        }
    }
    
    func clearCache() {
        cacheQueue.async(flags: .barrier) {
            self.cache.removeAllObjects()
        }
    }
}

/**
 * Represents a note in the Zettel application.
 * 
 * Each note is identified by its filename, making the system simple and straightforward.
 */
struct Note: Identifiable, Codable, Equatable {
    /// Display title of the note
    var title: String
    
    /// Full markdown content of the note
    var content: String
    
    /// Timestamp when the note was created
    var createdAt: Date
    
    /// Timestamp when the note was last modified
    var modifiedAt: Date

    /// String identifier derived from filename for Identifiable conformance
    var id: String {
        return filename
    }
    
    init(title: String = "", content: String = "") {
        self.title = title
        self.content = content
        let now = Date()
        self.createdAt = now
        self.modifiedAt = now
    }
    
    /// Updates the content and modifies the timestamp
    mutating func updateContent(_ newContent: String) {
        self.content = newContent
        self.modifiedAt = Date()
        // Invalidate tag cache using filename
        TagCacheManager.shared.invalidateCache(for: self.filename)
    }

    /// Updates the title and modifies the timestamp
    mutating func updateTitle(_ newTitle: String) {
        self.title = newTitle
        self.modifiedAt = Date()
        // Invalidate tag cache using filename
        TagCacheManager.shared.invalidateCache(for: self.filename)
    }
    
    
    /// Returns the auto-generated title based on creation date (filesystem-safe)
    var autoGeneratedTitle: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "HH-mm-ss â€“ d MMM yyyy"  // Use hyphens instead of colons
        return formatter.string(from: createdAt)
    }
    
    /// Returns the filename for saving this note
    var filename: String {
        // Use title as filename, removing illegal filesystem characters
        let cleanTitle = sanitizeForFilename(title.isEmpty ? autoGeneratedTitle : title)
        return "\(cleanTitle).md"
    }

    /// Generates a unique filename by checking for collisions and adding counters
    func generateUniqueFilename(in directory: URL) -> String {
        let baseTitle = sanitizeForFilename(title.isEmpty ? autoGeneratedTitle : title)
        var filename = "\(baseTitle).md"
        var counter = 1

        while FileManager.default.fileExists(atPath: directory.appendingPathComponent(filename).path) {
            filename = "\(baseTitle)_\(counter).md"
            counter += 1
        }

        return filename
    }
    
    /// Sanitizes a string for use as a filename by replacing illegal characters
    private func sanitizeForFilename(_ input: String) -> String {
        // Replace colons with hyphens to maintain readability for timestamps
        var sanitized = input.replacingOccurrences(of: ":", with: "-")
        
        // Characters that are illegal in filenames on most filesystems (excluding colon as we handle it above)
        let illegalCharacters = CharacterSet(charactersIn: "/\\*?\"<>|")
        
        // Remove remaining illegal characters and trim whitespace
        sanitized = sanitized
            .components(separatedBy: illegalCharacters)
            .joined()
            .trimmingCharacters(in: .whitespacesAndNewlines)
        
        // Ensure we have a non-empty filename
        return sanitized.isEmpty ? "Untitled" : sanitized
    }
    /// Returns a preview of the content (first few lines for overview)
    var contentPreview: String {
        return contentPreview(maxLines: 3)
    }
    
    /// Returns a preview of the content with specified max lines
    func contentPreview(maxLines: Int) -> String {
        let lines = content.components(separatedBy: .newlines)
        let previewLines = lines.prefix(maxLines)
        let preview = previewLines.joined(separator: "\n")
        return preview.isEmpty ? "Empty note" : preview
    }
    
    /// Serializes the note as plain markdown content
    var serializedContent: String {
        return content
    }

    /// Creates a Note from content with optional metadata
    static func fromSerializedContent(_ content: String, fallbackTitle: String? = nil) -> Note {
        // Create note with content and fallback title
        return Note(title: fallbackTitle ?? "", content: content)
    }
    
    /// Creates a Note from content with file metadata timestamps
    static func fromSerializedContent(_ content: String, fallbackTitle: String? = nil, createdAt: Date, modifiedAt: Date) -> Note {
        var note = Note(title: fallbackTitle ?? "", content: content)
        note.createdAt = createdAt
        note.modifiedAt = modifiedAt
        return note
    }
    
    // MARK: - Tag Support
    
    /// Extracts all tags from both title and content
    /// Uses global cache for performance optimization
    var extractedTags: Set<String> {
        return TagCacheManager.shared.getExtractedTags(for: self)
    }
    
    /// Returns all tags as Tag objects (for display purposes)
    var tagObjects: [Tag] {
        return extractedTags.map { Tag(name: $0) }.sorted { $0.displayName < $1.displayName }
    }
    
    /// Checks if the note contains a specific tag (case-insensitive)
    func hasTag(_ tagName: String) -> Bool {
        return extractedTags.contains(tagName.lowercased())
    }
    
    /// Returns a formatted string of all tags for display
    var tagDisplayString: String {
        let sortedTags = extractedTags.sorted()
        return sortedTags.map { "#\($0)" }.joined(separator: " ")
    }
}

// MARK: - Input Validation

extension Note {
    /// Validates note content and returns validation errors
    func validate() -> [ValidationError] {
        var errors: [ValidationError] = []
        
        // Validate title length
        if title.count > ValidationConstants.maxNoteTitleLength {
            errors.append(.titleTooLong(title.count, ValidationConstants.maxNoteTitleLength))
        }
        
        // Validate content length
        if content.count > ValidationConstants.maxNoteContentLength {
            errors.append(.contentTooLong(content.count, ValidationConstants.maxNoteContentLength))
        }
        
        // Validate extracted tags
        let extractedTags = self.extractedTags
        if extractedTags.count > ValidationConstants.maxTagsPerNote {
            errors.append(.tooManyTags(extractedTags.count, ValidationConstants.maxTagsPerNote))
        }
        
        // Validate individual tag lengths
        for tag in extractedTags {
            if tag.count > ValidationConstants.maxTagLength {
                errors.append(.tagTooLong(tag, ValidationConstants.maxTagLength))
            }
        }
        
        return errors
    }
    
    /// Checks if the note is valid
    var isValid: Bool {
        return validate().isEmpty
    }
    
    /// Sanitizes note content to ensure it's valid
    mutating func sanitize() {
        // Trim and limit title
        title = String(title.prefix(ValidationConstants.maxNoteTitleLength))
        
        // Trim and limit content
        content = String(content.prefix(ValidationConstants.maxNoteContentLength))
        
        // Update modification date after sanitization
        modifiedAt = Date()
    }
}

/// Validation errors for notes
enum ValidationError: LocalizedError {
    case titleTooLong(Int, Int) // current length, max length
    case contentTooLong(Int, Int) // current length, max length
    case tooManyTags(Int, Int) // current count, max count
    case tagTooLong(String, Int) // tag name, max length
    
    var errorDescription: String? {
        switch self {
        case .titleTooLong(let current, let max):
            return "Title is too long (\(current) characters). Maximum allowed: \(max) characters."
        case .contentTooLong(let current, let max):
            return "Content is too long (\(current) characters). Maximum allowed: \(max) characters."
        case .tooManyTags(let current, let max):
            return "Too many tags (\(current) tags). Maximum allowed: \(max) tags."
        case .tagTooLong(let tag, let max):
            return "Tag '\(tag)' is too long. Maximum allowed: \(max) characters."
        }
    }
}
