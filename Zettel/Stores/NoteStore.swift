//
//  NoteStore.swift
//  Zettel
//
//  Created for Zettel project
//
//  Core data management for notes including file I/O,
//  change monitoring, and data validation.
//

import Foundation
import SwiftUI
import UIKit
import UniformTypeIdentifiers
import AppIntents

/**
 * Manages the storage and retrieval of notes from the file system.
 * 
 * This class handles:
 * - Reading and writing note files
 * - Monitoring file system changes
 * - Managing note metadata and relationships
 * - Tag processing and management
 * - File validation and error handling
 */
@MainActor
class NoteStore: NSObject, ObservableObject, NSFilePresenter {
    /// The currently active note being edited
    @Published var currentNote: Note
    
    /// Previously saved notes from the file system
    @Published var archivedNotes: [Note] = []
    
    /// Directory where notes are stored
    @Published var storageDirectory: URL
    
    /// Controls whether the main view should be displayed
    @Published var shouldShowMainView: Bool = false
    
    /// Indicates if initial note loading is in progress
    @Published var isInitialLoadingNotes: Bool = false
    
    /// Tracks whether the initial load has completed at least once
    @Published var hasCompletedInitialLoad: Bool = false
    
    /// Tracks any error that occurred during note loading
    @Published var loadingError: Error?
    
    // Tag support
    @Published var tagStore = TagStore()
    
    // Original filename tracking for rename deletion logic
    // This is memory-only and gets reset when the app restarts
    private var originalFilename: String?
    
    // Settings
    
    private let storageDirectoryBookmarkKey = "storageDirectoryBookmark"
    private var storageDirectoryBookmark: Data?
    private let hasLaunchedBeforeKey = "hasLaunchedBefore"
    private var fileCoordinator: NSFileCoordinator?
    private nonisolated(unsafe) var _presentedItemURL: URL?
    
    // NSFilePresenter properties
    nonisolated var presentedItemURL: URL? {
        return _presentedItemURL
    }
    
    let presentedItemOperationQueue = OperationQueue()
    
    override init() {
        // Initialize with default directory first
        guard let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
            // Fallback to temporary directory if documents directory is unavailable
            print("Critical error: Unable to access documents directory, using temporary directory")
            self.storageDirectory = FileManager.default.temporaryDirectory
            // Create initial note with auto-generated title as fallback
            var initialNote = Note(title: "", content: "")
            initialNote.title = initialNote.autoGeneratedTitle
            self.currentNote = initialNote
            super.init()
            return
        }
        self.storageDirectory = documentsPath
        
        // Initialize original filename tracking as nil (new note, not loaded)
        self.originalFilename = nil
        
        // Create initial note (will be replaced with welcome note if first launch)
        var initialNote = Note(title: "", content: "")
        initialNote.title = initialNote.autoGeneratedTitle
        self.currentNote = initialNote
        
        super.init()
        
        self._presentedItemURL = self.storageDirectory

        // Try to restore saved storage directory and update if available
        if let restoredDirectory = restoreStorageDirectory() {
            self.storageDirectory = restoredDirectory
            self._presentedItemURL = self.storageDirectory
        }

        // Create directory if it doesn't exist
        createStorageDirectoryIfNeeded()

        // Don't load notes synchronously - defer to async method
        // Initialize tag store with empty notes for now
        tagStore.updateTagsImmediately(from: [])

        // Start monitoring file system changes
        startMonitoringFileSystem()
        
        // Set up shortcut notification listener
        setupShortcutNotificationListener()
        
        // Check if this is the first launch and create welcome note if needed
        // Do this after other setup to ensure it doesn't interfere with async loading
        if isFirstLaunch() {
            createWelcomeNote()
        }
    }
    
    deinit {
        NSFileCoordinator.removeFilePresenter(self)
        NotificationCenter.default.removeObserver(self)
    }
    
    // MARK: - Loading State Management
    
    /// Updates loading state with proper transitions
    private func updateLoadingState(isLoading: Bool, error: Error? = nil) {
        isInitialLoadingNotes = isLoading
        loadingError = error
        if !isLoading {
            hasCompletedInitialLoad = true
        }
    }
    
    /// Starts the initial note loading process asynchronously
    func startInitialNoteLoading() {
        Task { @MainActor in
            updateLoadingState(isLoading: true)
            do {
                try await loadArchivedNotesAsync()
                updateLoadingState(isLoading: false)
            } catch {
                updateLoadingState(isLoading: false, error: error)
                print("Error during initial note loading: \(error)")
            }
        }
    }
    
    /// Retry loading notes after an error
    func retryNoteLoading() {
        startInitialNoteLoading()
    }
    
    /// Asynchronous version of note loading that doesn't block the main thread
    private func loadArchivedNotesAsync() async throws {
        let result = try await Task.detached { [weak self] in
            guard let self = self else { 
                throw NoteError.fileSystemError("NoteStore was deallocated during loading")
            }
            
            // Perform file operations on background thread
            return try await self.performFileSystemScan()
        }.value
        
        // Update UI on main thread
        await MainActor.run {
            self.archivedNotes = result
            self.tagStore.updateTagsImmediately(from: result)
        }
    }
    
    /// Performs the actual file system scanning on a background thread
    private func performFileSystemScan() async throws -> [Note] {
        // Debug: Add sleep to test loading screen
        // try await Task.sleep(nanoseconds: 8_000_000_000) // 3 seconds
        
        // Start accessing the security-scoped resource if needed
        let didStartAccessing = storageDirectory.startAccessingSecurityScopedResource()
        defer {
            if didStartAccessing {
                storageDirectory.stopAccessingSecurityScopedResource()
            }
        }
        
        do {
            let fileURLs = try FileManager.default.contentsOfDirectory(
                at: storageDirectory, 
                includingPropertiesForKeys: [.creationDateKey, .contentModificationDateKey], 
                options: [.skipsHiddenFiles]
            )
            
            var notes: [Note] = []
            
            for fileURL in fileURLs where fileURL.pathExtension == "md" {
                if let content = try? String(contentsOf: fileURL, encoding: .utf8) {
                    // Get filename without extension as fallback title
                    let filenameWithoutExtension = fileURL.deletingPathExtension().lastPathComponent
                    
                    // Extract file metadata
                    let creationDate = getFileCreationDate(fileURL) ?? Date()
                    let modificationDate = getFileModificationDate(fileURL) ?? Date()
                    
                    // Create note with file metadata
                    let note = Note.fromSerializedContent(content, fallbackTitle: filenameWithoutExtension, createdAt: creationDate, modifiedAt: modificationDate)
                    notes.append(note)
                }
            }
            
            // Sort by modification date (most recently modified first)
            return notes.sorted { $0.modifiedAt > $1.modifiedAt }
            
        } catch {
            print("Error loading archived notes: \(error)")
            throw NoteError.fileSystemError("Failed to load notes: \(error.localizedDescription)")
        }
    }
    
    // MARK: - Shortcut Integration
    
    /// Sets up notification listener for shortcut-triggered actions
    private func setupShortcutNotificationListener() {
        NotificationCenter.default.addObserver(
            forName: .createNewNoteFromShortcut,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            Task { @MainActor in
                self?.handleCreateNewNoteFromShortcut()
            }
        }
    }
    
    /// Handles shortcut-triggered new note creation
    private func handleCreateNewNoteFromShortcut() {
        // Check if current note has content that would be lost
        if hasUnsavedContent() {
            // Trigger confirmation dialog in MainView
            NotificationCenter.default.post(
                name: .showNewNoteConfirmation,
                object: nil
            )
        } else {
            // Safe to create new note immediately
            createNewNoteFromShortcut()
        }
    }
    
    /// Creates new note specifically from shortcut (bypasses normal validation)
    func createNewNoteFromShortcut() {
        var newNote = Note(title: "", content: "")
        newNote.title = newNote.autoGeneratedTitle
        self.currentNote = newNote
        
        // Clear original filename since this is a new note
        originalFilename = nil
        
        // Add haptic feedback for shortcut action
        let successFeedback = UINotificationFeedbackGenerator()
        successFeedback.notificationOccurred(.success)
        
        // Ensure we're showing the main view
        shouldShowMainView = true
    }
    
    /// Checks if current note has unsaved content that would be lost
    private func hasUnsavedContent() -> Bool {
        return !currentNote.content.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ||
               (!currentNote.title.isEmpty && currentNote.title != currentNote.autoGeneratedTitle)
    }
    
    // MARK: - Note Management
    
    /// Creates a new note with auto-generated title
    func createNewNote() {
        var newNote = Note(title: "", content: "")
        newNote.title = newNote.autoGeneratedTitle
        self.currentNote = newNote
        
        // Clear original filename since this is a new note, not loaded from overview
        originalFilename = nil
    }
    
    /// Creates a welcome note for first-time app launch
    private func createWelcomeNote() {
        let welcomeContent = """
In Zettel, you can:

* swipe ← to see your notes
* swipe → (… line) to save

Happy #notetaking ^^
"""
        
        self.currentNote = Note(title: "Welcome to Zettel", content: welcomeContent)
        
        // Clear original filename since this is a new note, not loaded from overview
        originalFilename = nil
    }
    
    /// Checks if this is the first app launch and returns true if welcome note should be shown
    private func isFirstLaunch() -> Bool {
        let hasLaunchedBefore = UserDefaults.standard.bool(forKey: hasLaunchedBeforeKey)
        if !hasLaunchedBefore {
            UserDefaults.standard.set(true, forKey: hasLaunchedBeforeKey)
            return true
        }
        return false
    }
    
    /// Archives the current note and creates a new one
    func archiveCurrentNote() {
        // Validate and sanitize the note before archiving
        if !currentNote.isValid {
            currentNote.sanitize()
        }
        
        // If title is empty or is the auto-generated one, generate a new one
        if currentNote.title.isEmpty {
            currentNote.title = currentNote.autoGeneratedTitle
        }
        
        // Check if we need to delete the original file due to rename
        let shouldDeleteOriginal = shouldDeleteOriginalFile()
        let originalFileToDelete = originalFilename
        
        // Check if this note already exists in the archive using filename
        if let existingIndex = archivedNotes.firstIndex(where: { $0.filename == currentNote.filename }) {
            // Delete old file before saving updated one
            let oldNote = archivedNotes[existingIndex]
            deleteNoteFile(oldNote)
            // Update existing note in place
            archivedNotes[existingIndex] = currentNote
        } else {
            // Add new note to archive
            archivedNotes.append(currentNote)
        }
        
        // Sort by modification date to maintain proper order (most recently modified first)
        archivedNotes.sort { $0.modifiedAt > $1.modifiedAt }
        
        // Save current note to file first (atomic operation requirement)
        saveNoteToFile(currentNote)
        
        // Only delete original file after successful save and if it's different from current
        if shouldDeleteOriginal, let originalFile = originalFileToDelete {
            deleteOriginalFileIfExists(originalFile)
        }
        
        // Clear original filename tracking after processing
        originalFilename = nil
        
        // Add haptic feedback for successful note save
        let successFeedback = UINotificationFeedbackGenerator()
        successFeedback.notificationOccurred(.success)
        
        // Create new note
        createNewNote()
        
        // Update tag store with archived notes (immediate update for archiving)
        tagStore.updateTagsImmediately(from: archivedNotes)
    }
    
    /// Updates the current note's content
    func updateCurrentNoteContent(_ content: String) {
        currentNote.updateContent(content)
        
        // Validate and sanitize if needed
        if !currentNote.isValid {
            currentNote.sanitize()
        }
        
        // Only update tag store with archived notes (exclude current unsaved note)
        tagStore.scheduleTagUpdate(from: archivedNotes)
    }
    
    /// Deletes an archived note
    func deleteArchivedNote(_ note: Note) {
        // Remove from array
        archivedNotes.removeAll { $0.filename == note.filename }
        
        // Delete file
        deleteNoteFile(note)
        
        // Update tag store after deletion (immediate update)
        tagStore.updateTagsImmediately(from: archivedNotes)
    }
    
    /// Deletes an archived note by filename
    func deleteArchivedNote(withFilename filename: String) {
        if let note = archivedNotes.first(where: { $0.filename == filename }) {
            deleteArchivedNote(note)
        }
    }
    
    /// Loads an archived note into the current note for editing
    func loadArchivedNoteAsCurrent(_ note: Note) {
        // Save current note if it has content
        if !currentNote.content.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
            archiveCurrentNote()
        }
        
        // Store the original filename for rename deletion logic
        originalFilename = note.filename
        
        // Load the note for editing (keeping all properties including ID)
        currentNote = note
    }
    
    // MARK: - File Management
    
    private func createStorageDirectoryIfNeeded() {
        // Start accessing the security-scoped resource if needed
        let didStartAccessing = storageDirectory.startAccessingSecurityScopedResource()
        defer {
            if didStartAccessing {
                storageDirectory.stopAccessingSecurityScopedResource()
            }
        }
        
        do {
            try FileManager.default.createDirectory(at: storageDirectory, withIntermediateDirectories: true)
        } catch {
            print("Error creating storage directory: \(error)")
        }
    }
    
    /**
     * Saves a note to the file system with proper error handling and security scoping.
     * 
     * This method:
     * - Handles security-scoped resource access for sandboxed environments
     * - Generates unique filenames to avoid collisions
     * - Validates file content with checksums
     * - Maintains file system consistency
     * 
     * - Parameter note: The note to save to disk
     */
    private func saveNoteToFile(_ note: Note) {
        // Start accessing the security-scoped resource if needed
        let didStartAccessing = storageDirectory.startAccessingSecurityScopedResource()
        defer {
            if didStartAccessing {
                storageDirectory.stopAccessingSecurityScopedResource()
            }
        }

        // Generate unique filename to avoid collisions
        let uniqueFilename = note.generateUniqueFilename(in: storageDirectory)
        let fileURL = storageDirectory.appendingPathComponent(uniqueFilename)

        do {
            try note.serializedContent.write(to: fileURL, atomically: true, encoding: .utf8)
        } catch {
            print("Error saving note to file: \(error)")
        }
    }
    
    private func deleteNoteFile(_ note: Note) {
        // Start accessing the security-scoped resource if needed
        let didStartAccessing = storageDirectory.startAccessingSecurityScopedResource()
        defer {
            if didStartAccessing {
                storageDirectory.stopAccessingSecurityScopedResource()
            }
        }
        
        let fileURL = storageDirectory.appendingPathComponent(note.filename)
        
        do {
            if FileManager.default.fileExists(atPath: fileURL.path) {
                try FileManager.default.removeItem(at: fileURL)
            }
        } catch {
            print("Error deleting note file: \(error)")
        }
    }
    
    /// Determines if the original file should be deleted due to rename
    private func shouldDeleteOriginalFile() -> Bool {
        // Only delete if we have an original filename and it's different from current
        guard let original = originalFilename else { return false }
        return original != currentNote.filename
    }
    
    /// Safely deletes the original file if it exists, with proper error handling
    private func deleteOriginalFileIfExists(_ originalFilename: String) {
        // Start accessing the security-scoped resource if needed
        let didStartAccessing = storageDirectory.startAccessingSecurityScopedResource()
        defer {
            if didStartAccessing {
                storageDirectory.stopAccessingSecurityScopedResource()
            }
        }
        
        let originalFileURL = storageDirectory.appendingPathComponent(originalFilename)
        
        do {
            // Check if original file exists before attempting deletion
            if FileManager.default.fileExists(atPath: originalFileURL.path) {
                try FileManager.default.removeItem(at: originalFileURL)
                print("Successfully deleted original file: \(originalFilename)")
            } else {
                // Original file doesn't exist - this is fine, may have been deleted externally
                print("Original file no longer exists (external deletion): \(originalFilename)")
            }
        } catch {
            // Log error but don't crash - this is not a critical failure
            print("Warning: Could not delete original file \(originalFilename): \(error)")
        }
    }
    
    private func loadArchivedNotes() {
        // Start accessing the security-scoped resource if needed
        let didStartAccessing = storageDirectory.startAccessingSecurityScopedResource()
        defer {
            if didStartAccessing {
                storageDirectory.stopAccessingSecurityScopedResource()
            }
        }
        
        do {
            let fileURLs = try FileManager.default.contentsOfDirectory(at: storageDirectory, includingPropertiesForKeys: [.creationDateKey, .contentModificationDateKey], options: [.skipsHiddenFiles])
            
            var notes: [Note] = []
            
            for fileURL in fileURLs where fileURL.pathExtension == "md" {
                if let content = try? String(contentsOf: fileURL, encoding: .utf8) {
                    // Get filename without extension as fallback title
                    let filenameWithoutExtension = fileURL.deletingPathExtension().lastPathComponent
                    
                    // Extract file metadata
                    let creationDate = getFileCreationDate(fileURL) ?? Date()
                    let modificationDate = getFileModificationDate(fileURL) ?? Date()
                    
                    // Create note with file metadata
                    let note = Note.fromSerializedContent(content, fallbackTitle: filenameWithoutExtension, createdAt: creationDate, modifiedAt: modificationDate)
                    notes.append(note)
                }
            }
            
            // Sort by modification date (most recently modified first)
            self.archivedNotes = notes.sorted { $0.modifiedAt > $1.modifiedAt }
            
            // Update tag store with archived notes only
            tagStore.updateTagsImmediately(from: notes)
            
        } catch {
            print("Error loading archived notes: \(error)")
        }
    }
    
    private func getFileCreationDate(_ fileURL: URL) -> Date? {
        do {
            let attributes = try FileManager.default.attributesOfItem(atPath: fileURL.path)
            return attributes[.creationDate] as? Date
        } catch {
            return nil
        }
    }
    
    private func getFileModificationDate(_ fileURL: URL) -> Date? {
        do {
            let attributes = try FileManager.default.attributesOfItem(atPath: fileURL.path)
            return attributes[.modificationDate] as? Date
        } catch {
            return nil
        }
    }
    
    // MARK: - Settings
    
    func updateStorageDirectory(_ newDirectory: URL) {
        // Stop monitoring old directory
        stopMonitoringFileSystem()
        
        // Start accessing the security-scoped resource
        let didStartAccessing = newDirectory.startAccessingSecurityScopedResource()
        defer {
            if didStartAccessing {
                newDirectory.stopAccessingSecurityScopedResource()
            }
        }
        
        // Save bookmark for persistence
        saveStorageDirectoryBookmark(newDirectory)
        
        self.storageDirectory = newDirectory
        self._presentedItemURL = self.storageDirectory
        createStorageDirectoryIfNeeded()
        loadArchivedNotes()
        
        // Start monitoring new directory
        startMonitoringFileSystem()
    }
    
    
    // MARK: - Auto-save
    
    // Note: Draft saving functionality has been removed.
    // Drafts are now kept in memory only and saved to file only when ripping off.
    
    // MARK: - Storage Directory Persistence
    
    private func saveStorageDirectoryBookmark(_ url: URL) {
        do {
            let bookmark = try url.bookmarkData(
                options: [],
                includingResourceValuesForKeys: nil,
                relativeTo: nil
            )
            UserDefaults.standard.set(bookmark, forKey: storageDirectoryBookmarkKey)
        } catch {
            print("Error saving storage directory bookmark: \(error)")
        }
    }
    
    private func restoreStorageDirectory() -> URL? {
        guard let bookmark = UserDefaults.standard.data(forKey: storageDirectoryBookmarkKey) else {
            return nil
        }
        
        do {
            var isStale = false
            let url = try URL(
                resolvingBookmarkData: bookmark,
                options: [],
                relativeTo: nil,
                bookmarkDataIsStale: &isStale
            )
            
            if isStale {
                // Re-save the bookmark
                saveStorageDirectoryBookmark(url)
            }
            
            // Start accessing the security-scoped resource
            if url.startAccessingSecurityScopedResource() {
                // Note: We're not stopping access here as we'll need it throughout the app's lifecycle
                return url
            }
            
            return url
        } catch {
            print("Error restoring storage directory: \(error)")
            return nil
        }
    }
    
    // MARK: - File System Monitoring
    
    nonisolated private func startMonitoringFileSystem() {
        Task { @MainActor in
            fileCoordinator = NSFileCoordinator(filePresenter: self)
            // Add file presenter after coordinator is initialized
            NSFileCoordinator.addFilePresenter(self)
        }
    }
    
    nonisolated private func stopMonitoringFileSystem() {
        NSFileCoordinator.removeFilePresenter(self)
        Task { @MainActor in
            fileCoordinator = nil
        }
    }
    
    // MARK: - NSFilePresenter
    
    nonisolated func presentedSubitemDidChange(at url: URL) {
        // A file in our directory changed
        Task { @MainActor in
            refreshArchivedNotes()
        }
    }
    
    nonisolated func presentedItemDidChange() {
        // The directory itself changed
        Task { @MainActor in
            refreshArchivedNotes()
        }
    }
    
    nonisolated func presentedSubitemDidAppear(at url: URL) {
        // A new file appeared
        Task { @MainActor in
            refreshArchivedNotes()
        }
    }
    
    nonisolated func presentedSubitem(at oldURL: URL, didMoveTo newURL: URL) {
        // A file was renamed
        Task { @MainActor in
            refreshArchivedNotes()
        }
    }
    
    private func refreshArchivedNotes() {
        // Don't refresh if initial loading is in progress
        guard !isInitialLoadingNotes else { return }
        
        // For subsequent refreshes, use the original synchronous method
        // This ensures external changes are picked up quickly
        loadArchivedNotes()
    }
    
    // MARK: - External File Loading
    
    /// Loads an external file and sets it as the current note
    func loadExternalFile(_ url: URL) async {
        // Start accessing the security-scoped resource
        let didStartAccessing = url.startAccessingSecurityScopedResource()
        defer {
            if didStartAccessing {
                url.stopAccessingSecurityScopedResource()
            }
        }
        
        do {
            // Read the file content
            let content = try String(contentsOf: url, encoding: .utf8)
            
            // Extract filename without extension for title
            let filename = url.deletingPathExtension().lastPathComponent
            
            // Save current note if it has content
            if !currentNote.content.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                archiveCurrentNote()
            }
            
            // Create new note from external file
            // Use filename as title and current date as creation date
            var newNote = Note(title: filename, content: content)
            
            // Check if content has our metadata header and parse it
            let parsedNote = Note.fromSerializedContent(content, fallbackTitle: filename)
            newNote = parsedNote
            // Override the title with the filename if the parsed title is empty
            if newNote.title.isEmpty {
                newNote.title = filename
            }
            
            // Set as current note
            currentNote = newNote
            
            // Clear original filename since this is an external file load, not from overview
            originalFilename = nil
            
            // Trigger navigation to main view
            shouldShowMainView = true
            
        } catch {
            print("Error loading external file: \(error)")
        }
    }
    
    // MARK: - Tag-related methods
    
    /// Gets all notes that contain a specific tag
    func getNotesWithTag(_ tagName: String) -> [Note] {
        return tagStore.getNotesWithTag(tagName, from: archivedNotes)
    }
    
    /// Gets notes that contain any of the specified tags
    func getNotesWithAnyTag(_ tagNames: Set<String>) -> [Note] {
        return tagStore.getNotesWithAnyTag(tagNames, from: archivedNotes)
    }
    
    /// Gets notes that contain all of the specified tags
    func getNotesWithAllTags(_ tagNames: Set<String>) -> [Note] {
        return tagStore.getNotesWithAllTags(tagNames, from: archivedNotes)
    }
}
